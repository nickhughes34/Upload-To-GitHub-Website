<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<style type="text/css">
html {pointer-events: none;}

    h4 
    {
        text-align: left;
    }

@media screen 
{

	.headerLineTitle
	{
		width:1.5in;
		display:inline-block;
		margin:0in;
		margin-bottom:.0001pt;
		font-size:11.0pt;
		font-family:"Calibri","sans-serif";
		font-weight:bold;
	}

	.headerLineText
	{
		display:inline;
		margin:0in;
		margin-bottom:.0001pt;
		font-size:11.0pt;
		font-family:"Calibri","sans-serif";
		font-weight:normal;
	}

   .pageHeader
   {
		font-size:14.0pt;
		font-family:"Calibri","sans-serif";
		font-weight:bold;
		visibility:hidden;
		display:none;
   }   
}

@media print 
{
	.headerLineTitle
	{
		width:1.5in;
		display:inline-block;
		margin:0in;
		margin-bottom:.0001pt;
		font-size:11.0pt;
		font-family:"Calibri","sans-serif";
		font-weight:bold;
	}

	.headerLineText
	{
		display:inline;
		margin:0in;
		margin-bottom:.0001pt;
		font-size:11.0pt;
		font-family:"Calibri","sans-serif";
		font-weight:normal;
	}

   .pageHeader
   {
		font-size:14.0pt;
		font-family:"Calibri","sans-serif";
		font-weight:bold;
		visibility:visible;
		display:block;
   }

}
</style>
</head>
<body>
<span class='headerLineTitle'>Subject:</span><span class='headerLineText'>asynchronous I/O (was Re: Gasp!)</span><br/><br/>
<font size="2"><div class="PlainText">Of course we've had select() since BSD 4.2 and poll() since System V<br>
or so, and they work reasonably well for asynchronous I/O up to a<br>
hundred or so channels, but suck after that; /dev/poll (available in<br>
Solaris and Linux) is one approach to solving this; Linux has a way to<br>
do essentially the same thing with real-time signals, and has for<br>
years; and FreeBSD has kqueue.<br>
<br>
More details about these are at<br>
<a href="http://www.citi.umich.edu/projects/linux-scalability/">http://www.citi.umich.edu/projects/linux-scalability/</a><br>
<br>
None of this helps with disk I/O; most programs that need to overlap<br>
disk I/O with computation, on either proprietary Unixes or Linux, just<br>
use multiple threads or processes to handle the disk I/O.<br>
<br>
POSIX specifies a mechanism for nonblocking disk I/O that most<br>
proprietary Unixes implement.&nbsp; The Linux kernel hackers are currently<br>
rewriting Linux's entire I/O subsystem essentially from scratch to<br>
work asynchronously, because they can easily build efficient<br>
synchronous I/O primitives from asynchronous ones, but not the other<br>
way around. So now Linux will support this mechanism too.<br>
<br>
It probably doesn't need saying for anyone who's read Beberg saying<br>
things like &quot;Memory management is a non-issue for anyone that has any<br>
idea at all how the hardware functions,&quot; but he's totally off-base.<br>
People should know by now not to take anything he says seriously, but<br>
apparently some don't, so I'll rebut.<br>
<br>
Not surprisingly, the rebuttal requires many more words than the<br>
original stupid errors.<br>
<br>
In detail, he wrote:<br>
&gt; Could it be? After 20 years without this feature UNIX finally<br>
&gt; catches up to Windows and has I/O that doesnt [sic] totally suck for<br>
&gt; nontrivial apps? No way!<br>
<br>
Unix acquired nonblocking I/O in the form of select() about 23 years<br>
ago, and Solaris has had the particular aio_* calls we are discussing<br>
for many years.&nbsp; Very few applications need the aio_* calls ---<br>
essentially only high-performance RDBMS servers even benefit from them<br>
at all, and most of those have been faking it fine for a while with<br>
multiple threads or processes.&nbsp; This just provides a modicum of extra<br>
performance.<br>
<br>
&gt; OK, so they do it with signals or a flag, which is completely<br>
&gt; ghetto, but at least they are trying. Keep trying guys, you got the<br>
&gt; idea, but not the clue.<br>
<br>
Readers can judge who lacks the clue here.<br>
<br>
&gt; The Windows I/O model does definately [sic] blow the doors off the<br>
&gt; UNIX one, but then they had select to point at in it's [sic]<br>
&gt; suckiness and anything would have been an improvement. UNIX is just<br>
&gt; now looking at it's [sic] I/O model and adapting to a multiprocess<br>
&gt; multithreaded world so it's gonna be years yet before a posix API<br>
&gt; comes out of it.<br>
<br>
Although I don't have a copy of the spec handy, I think the aio_* APIs<br>
come from the POSIX spec IEEE Std 1003.1-1990, section 6.7.9, which is<br>
13 years old, and which I think documented then-current practice.<br>
They might be even older than that.<br>
<br>
Unix has been multiprocess since 1969, and most Unix implementations<br>
have supported multithreading for a decade or more.<br>
<br>
&gt; Bottom line is the &quot;do stuff when something happens&quot; model turned<br>
&gt; out to be right, and the UNIX &quot;look for something to do and keep<br>
&gt; looking till you find it no matter how many times you have to look&quot;<br>
&gt; is not really working so great anymore.<br>
<br>
Linux's aio_* routines can notify the process of their completion with<br>
a &quot;signal&quot;, a feature missing in Microsoft Windows; a &quot;signal&quot; causes<br>
the immediate execution of a &quot;signal handler&quot; in a process.&nbsp; By<br>
contrast, the Microsoft Windows mechanisms to do similar things (such<br>
as completion ports) do not deliver a notification until the process<br>
polls them.<br>
<br>
I don't think signals are a better way to do things in this case<br>
(although I haven't written any RDBMSes myself), but you got the<br>
technical descriptions of the two operating systems exactly backwards.<br>
Most programs that use Linux real-time signals for asynchronous<br>
network I/O, in fact, block the signal in question and poll the signal<br>
queue in a very Windowsish way, using sigtimedwait() or sigwaitinfo().<br>
<br>
-- <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Kragen Sitaker&nbsp;&nbsp;&nbsp;&nbsp; <br>
Edsger Wybe Dijkstra died in August of 2002.&nbsp; This is a terrible loss after <br>
which the world will never be the same.<br>
<a href="http://www.xent.com/pipermail/fork/2002-August/013974.html">http://www.xent.com/pipermail/fork/2002-August/013974.html</a><br>
</div></font>
</body>
</html>
